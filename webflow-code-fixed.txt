================================================================================
WEBFLOW VIDEO SHADER - HERO + FEATURE ANIMATIONS
================================================================================

STEP 1: Upload all 227 WebP files from the "frames" folder to Webflow Assets (for hero video)

STEP 2A: LOGO LOADER (Optional) - Add a wrapper DIV for your loading animation:
   - Attribute: logo-loader
   - Value: 1
   - This element stays visible until hero frames are loaded (minimum 3 seconds)
   - After loading, it fades out with a 0.5s opacity transition
   - Style: position fixed, full screen, high z-index, opacity 1

STEP 2B: HERO VIDEO SHADER - In Webflow Designer, add a DIV with these custom attributes:
   - Attribute: shader
   - Value: video (this will play the frame sequence animation)
   - (Optional) Attribute: shader-delay
   - (Optional) Value: delay in milliseconds (e.g., 1000 for 1 second delay)
   - Inside: add an IMAGE with Src: ./frames/frame_0001.webp
   - Custom Attribute on IMAGE: crossorigin="anonymous"
   Note: Hero animation starts AFTER logo loader fades out
   Note: Animation is in TWO PARTS:
         Part 1 = Pixel animation (big to small) on FIRST frame
         Part 2 = Image sequencing starts AFTER Part 1 completes

STEP 2C: FEATURE SHADERS - For feature images (right sticky panel), add a DIV with:
   - Attribute: feature
   - Value: number (1, 2, or 3)
   - (Optional) Attribute: shader-delay
   - (Optional) Value: delay in milliseconds (e.g., 1000 for 1 second delay)
   - Inside: add an IMAGE with your image source
   - Custom Attribute on IMAGE: crossorigin="anonymous"
   Note: Each feature can have its own frame sequence directory configured
   Note: Features use PING-PONG loop (plays forward, then reverse, then repeats)
   Note: Feature frames load ON-DEMAND when trigger enters viewport (not at page load)
   Note: Animation is TWO PARTS (same as hero)
   âœ… RESPONSIVE: You can add the same feature attribute to MULTIPLE elements
      (e.g., feature="1" on both desktop and mobile images - both will be initialized)

STEP 2D: FEATURE TRIGGERS - On the left side text content for each feature, add:
   - Attribute: feature-trigger
   - Value: number matching the feature (1, 2, or 3)
   - The shader animates when this trigger element reaches 40% from top of viewport
   - This is REQUIRED for sticky panel layouts where all images are in viewport at once

STEP 3: Style the DIVs:
   HERO (shader="video"):
   - Position: Fixed
   - Top: 0, Left: 0
   - Width: 100vw, Height: 100vh
   - Background: Black
   - Overflow: Hidden
   
   FEATURES (feature="1", feature="2", feature="3"):
   - Style as needed for your layout
   - Recommended: Set a defined width and height
   - Can be positioned anywhere in your layout
   - Same shader animation style applied to all features
   - Each can have different frame sequence configured in code

STEP 4: Copy the code below into Webflow Project Settings > Custom Code > Footer Code

================================================================================

<script type="module">
  import {
    ShaderMount,
    HalftoneDotsGrids,
    HalftoneDotsTypes,
    ShaderFitOptions,
    getShaderColorFromString,
    halftoneDotsFragmentShader,
    defaultObjectSizing
  } from "https://esm.sh/@paper-design/shaders@0.0.68";

  import { animate } from "https://esm.sh/motion@12.23.26";

  /* =====================================================
     GLOBAL LOADER CONTROL
  ===================================================== */
  const LOADER_MIN_TIME = 3000; // 3 seconds minimum loader display

  // âš ï¸ WRAP EVERYTHING IN DOM READY TO ENSURE ELEMENTS EXIST
  async function initShaders() {
    console.log("ğŸ¬ Initializing all shaders...");

    /* =====================================================
       LOGO LOADER (logo-loader="1")
       Hides after MAX(3 seconds, hero frames loaded)
    ===================================================== */
    const logoLoader = document.querySelector('[logo-loader="1"]');
    const loaderStartTime = Date.now();
    let heroFramesReady = false;
    let minTimeReached = false;
    let loaderHidden = false;
    let heroController = null;

    function tryHideLoader() {
      if (!heroFramesReady || !minTimeReached || loaderHidden) return;
      loaderHidden = true;
      
      console.log("âœ… Loader conditions met - hiding loader and starting hero animation...");
      
      if (logoLoader) {
        logoLoader.style.transition = 'opacity 0.5s ease-out';
        logoLoader.style.opacity = '0';
        setTimeout(() => {
          logoLoader.style.display = 'none';
          console.log("ğŸš€ Loader hidden!");
        }, 500);
      }
      
      // Start hero pixel animation after loader starts fading
      if (heroController) {
        heroController.startPixelAnimation();
      }
    }

    // Set minimum time flag after 3 seconds
    setTimeout(() => {
      console.log("â±ï¸ Minimum 3 seconds reached");
      minTimeReached = true;
      tryHideLoader();
    }, LOADER_MIN_TIME);

    /* =====================================================
       HERO VIDEO ANIMATION (shader="video")
    ===================================================== */
    const heroCanvas = document.querySelector('[shader="video"]');
    
    if (heroCanvas) {
      console.log("ğŸ¥ Initializing hero video shader...");
      heroController = await initHeroVideoShader(heroCanvas, () => {
        // Callback when hero frames are loaded
        console.log("âœ… Hero frames loaded!");
        heroFramesReady = true;
        tryHideLoader();
      });
    } else {
      // No hero, skip loader and let features handle themselves
      heroFramesReady = true;
      minTimeReached = true;
    }

    /* =====================================================
       FEATURE SHADERS (feature="1", feature="2", feature="3")
       Uses external triggers (feature-trigger="1", etc.) for scroll detection
       âš ï¸ Supports MULTIPLE elements per feature (e.g., desktop + mobile)
       âš ï¸ Frame loading is ON-DEMAND (starts when trigger enters viewport)
    ===================================================== */
    const featureControllers = new Map(); // Map<featureNum, controller[]>
    
    // Initialize all 3 features - find ALL elements with each feature attribute
    for (let i = 1; i <= 3; i++) {
      // Use querySelectorAll to get ALL elements (desktop + mobile)
      const featureCanvases = document.querySelectorAll(`[feature="${i}"]`);
      const featureTrigger = document.querySelector(`[feature-trigger="${i}"]`);
      
      if (featureCanvases.length > 0) {
        console.log(`ğŸ¨ Initializing feature ${i} shader... (${featureCanvases.length} element(s) found - desktop + mobile)`);
        
        // Initialize shader on ALL matching elements
        const controllers = [];
        for (const canvas of featureCanvases) {
          const controller = await initFeatureShader(canvas, i);
          if (controller) {
            controllers.push(controller);
          }
        }
        
        if (controllers.length > 0) {
          featureControllers.set(i, controllers);
        }
      }
      
      if (featureTrigger && featureControllers.has(i)) {
        console.log(`ğŸ¯ Feature ${i}: External trigger found`);
      } else if (featureCanvases.length > 0 && !featureTrigger) {
        console.warn(`âš ï¸ Feature ${i}: No trigger element found! Add feature-trigger="${i}" to the left-side text content.`);
      }
    }
    
    // Set up external trigger observers
    const triggerObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return;

          const featureNum = parseInt(entry.target.getAttribute("feature-trigger"));
          const controllers = featureControllers.get(featureNum);
          
          if (!controllers || controllers.length === 0) {
            console.warn(`âš ï¸ No shader controllers found for feature ${featureNum}`);
            return;
          }

          console.log(`ğŸ¯ Feature ${featureNum}: Trigger activated! Starting ${controllers.length} shader(s)...`);
          // Start ALL controllers for this feature (desktop + mobile)
          controllers.forEach(controller => controller.startPixelAnimation());
          triggerObserver.unobserve(entry.target);
        });
      },
      {
        rootMargin: "-40% 0px -40% 0px" // Trigger when element is in middle 20% of viewport
      }
    );

    // Observe all feature triggers
    document.querySelectorAll('[feature-trigger]').forEach((el) => {
      triggerObserver.observe(el);
    });
  }

  /* =====================================================
     HERO VIDEO SHADER WITH FRAME SEQUENCE
     Two-Part Animation:
       Part 1: Pixel animation (big to small) on FIRST frame only
       Part 2: Image sequencing starts AFTER Part 1 completes
  ===================================================== */
  async function initHeroVideoShader(canvas, onFramesLoaded) {
    const TOTAL_FRAMES = 227;
    const FPS = 30;
    
    // âš ï¸ UPDATE THIS PATH TO YOUR WEBFLOW ASSET URL
    const FRAMES_DIR = "https://liberty-shaders.vercel.app/frames";
    
    const frameImages = [];
    let framesLoaded = 0;
    let shader = null;
    let shaderReady = false;

    const img = canvas?.querySelector("img");
    
    if (!img) {
      console.error("âŒ Image inside hero shader container not found!");
      return null;
    }

    console.log("âœ… Hero shader container and image found");
    console.log("ğŸ“¸ Image source:", img.src);

    // Get delay from custom attribute (in milliseconds)
    const delayMs = parseInt(canvas.getAttribute('shader-delay')) || 0;
    console.log(`â±ï¸ Hero shader delay: ${delayMs}ms`);

    img.style.opacity = "0";
    img.style.pointerEvents = "none";

    // âš¡ Load ALL frames before starting (for two-part animation)
    const BATCH_SIZE = 30;
    
    console.log("â³ Loading ALL hero frames before animation starts...");
    
    async function loadFrameBatch(startIndex, endIndex) {
      const promises = [];
      for (let i = startIndex; i <= endIndex && i <= TOTAL_FRAMES; i++) {
        const frameImg = new Image();
        frameImg.crossOrigin = "anonymous";
        const paddedIndex = String(i).padStart(4, "0");
        
        const promise = new Promise((resolve) => {
          frameImg.onload = () => {
            framesLoaded++;
            resolve();
          };
          frameImg.onerror = () => {
            console.error(`âŒ Failed to load frame ${i}`);
            resolve(); // Continue even on error
          };
        });
        
        frameImg.src = `${FRAMES_DIR}/frame_${paddedIndex}.webp`;
        frameImages[i - 1] = frameImg; // Store at correct index
        promises.push(promise);
      }
      await Promise.all(promises);
    }
    
    // Load ALL frames before notifying ready
    (async () => {
      for (let batch = 0; batch * BATCH_SIZE < TOTAL_FRAMES; batch++) {
        const start = batch * BATCH_SIZE + 1;
        const end = Math.min((batch + 1) * BATCH_SIZE, TOTAL_FRAMES);
        await loadFrameBatch(start, end);
        console.log(`ğŸ“¦ Hero: ${framesLoaded}/${TOTAL_FRAMES} frames loaded...`);
      }
      
      console.log(`âœ… All ${TOTAL_FRAMES} hero frames loaded!`);
      
      // Signal that frames are ready (triggers loader hide)
      if (onFramesLoaded) {
        onFramesLoaded();
      }
    })();

    // Shader preset for hero
    const preset = {
      ...defaultObjectSizing,
      fit: "cover",
      speed: 0,
      frame: 0,
      colorBack: "#ffffff",
      colorFront: "#b2aeae",
      size: 0.6,
      radius: 2,
      contrast: 0.01,
      originalColors: true,
      grainMixer: 0,
      grainOverlay: 0,
      grainSize: 0.5,
      grid: "square",
      type: "holes",
      image: img.src
    };

    const uniformsProp = {
      u_image: preset.image,
      u_size: preset.size,
      u_radius: preset.radius,
      u_contrast: preset.contrast,
      u_originalColors: preset.originalColors,
      u_inverted: preset.inverted,
      u_grainMixer: preset.grainMixer,
      u_grainOverlay: preset.grainOverlay,
      u_grainSize: preset.grainSize,
      u_rotation: preset.rotation,
      u_scale: preset.scale,
      u_offsetX: preset.offsetX,
      u_offsetY: preset.offsetY,
      u_originX: preset.originX,
      u_originY: preset.originY,
      u_worldWidth: preset.worldWidth,
      u_worldHeight: preset.worldHeight,
      u_colorFront: getShaderColorFromString(preset.colorFront),
      u_colorBack: getShaderColorFromString(preset.colorBack),
      u_grid: HalftoneDotsGrids[preset.grid],
      u_type: HalftoneDotsTypes[preset.type],
      u_fit: ShaderFitOptions[preset.fit]
    };

    async function processUniforms(props) {
      const out = {};
      const promises = [];

      Object.entries(props).forEach(([k, v]) => {
        if (typeof v === "string") {
          const i = new Image();
          i.crossOrigin = "anonymous";
          const p = new Promise((res, rej) => {
            i.onload = () => { out[k] = i; res(); };
            i.onerror = rej;
          });
          i.src = v;
          promises.push(p);
        } else {
          out[k] = v;
        }
      });

      await Promise.all(promises);
      return out;
    }

    // Initialize hero shader
    try {
      console.log("ğŸ”§ Processing hero uniforms...");
      const uniforms = await processUniforms(uniformsProp);
      
      console.log("ğŸ¨ Creating hero shader instance...");
      shader = new ShaderMount(
        canvas,
        halftoneDotsFragmentShader,
        uniforms,
        {},
        preset.speed,
        preset.frame,
        preset.minPixelRatio,
        preset.maxPixelCount,
        preset.mipmaps
      );

      console.log("âœ… Hero shader created successfully!");
      shader.setUniforms({ u_size: 1 }); // Start with large pixels
      shaderReady = true;

    } catch (error) {
      console.error("âŒ Hero shader initialization error:", error);
      return null;
    }

    // Return controller for external triggering
    const controller = {
      pixelAnimationStarted: false,
      sequenceStarted: false,
      
      // Part 1: Pixel animation on FIRST frame only
      startPixelAnimation() {
        if (this.pixelAnimationStarted) return;
        this.pixelAnimationStarted = true;
        
        console.log("ğŸ¬ Hero Part 1: Starting pixel animation (on first frame)...");
        
        // Ensure first frame is displayed during pixel animation
        if (frameImages[0] && frameImages[0].complete) {
          shader.setUniforms({ u_image: frameImages[0] });
        }
        
        setTimeout(() => {
          animate(1, 0.1, {
            duration: 6,
            ease: [0.36, -0.01, 0.41, 1.01],
            onUpdate: (u_size) => {
              shader.setUniforms({ u_size });
            },
            onComplete: () => {
              console.log("âœ… Hero Part 1 complete! Starting Part 2...");
              // Part 2: Start image sequencing after pixel animation
              this.startSequence();
            }
          });
        }, delayMs);
      },
      
      // Part 2: Image sequencing (after pixel animation completes)
      startSequence() {
        if (this.sequenceStarted) return;
        this.sequenceStarted = true;
        startVideoAnimation();
      }
    };
    
    return controller;

    function startVideoAnimation() {
      console.log("ğŸ¥ Starting video animation loop (using requestAnimationFrame)...");
      
      let currentFrame = 0;
      const frameDuration = 1000 / FPS; // ms per frame
      let lastFrameTime = 0;
      let loopStarted = false;
      let isPaused = false;

      // âš¡ PERFORMANCE: Pause animation when hero is not visible
      const visibilityObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            isPaused = !entry.isIntersecting;
            if (isPaused) {
              console.log("â¸ï¸ Hero paused (not visible)");
            } else {
              console.log("â–¶ï¸ Hero resumed (visible)");
              lastFrameTime = 0; // Reset timing to avoid jump
            }
          });
        },
        { threshold: 0.1 }
      );
      visibilityObserver.observe(canvas);

      function animationLoop(timestamp) {
        // Request next frame immediately for smooth loop
        requestAnimationFrame(animationLoop);
        
        // âš¡ PERFORMANCE: Skip updates when paused/not visible
        if (isPaused) return;
        
        // Wait for shader to be ready
        if (!shader || !shaderReady) return;

        // Wait for minimum frames to be loaded
        if (framesLoaded < 30) return;

        if (!loopStarted) {
          console.log("ğŸ¬ Video animation started!");
          loopStarted = true;
          lastFrameTime = timestamp;
        }

        // Time-based frame advancement (smoother than setInterval)
        const elapsed = timestamp - lastFrameTime;
        
        if (elapsed >= frameDuration) {
          // Only play frames that are loaded
          const maxFrame = Math.min(framesLoaded, TOTAL_FRAMES) - 1;
          const nextImage = frameImages[currentFrame];
          
          if (nextImage && nextImage.complete) {
            shader.setUniforms({ u_image: nextImage });
          }

          currentFrame = (currentFrame + 1) % (maxFrame + 1);
          
          // Account for any lag to maintain consistent speed
          lastFrameTime = timestamp - (elapsed % frameDuration);
        }
      }

      // Start the animation loop
      requestAnimationFrame(animationLoop);
    }
  }

  /* =====================================================
     FEATURE SHADER WITH IMAGE SEQUENCE (SCROLL-TRIGGERED)
  ===================================================== */
  async function initFeatureShader(canvas, featureNumber) {
    // âš ï¸ CONFIGURE FRAME DIRECTORIES FOR EACH FEATURE HERE
    const FEATURE_CONFIGS = {
      1: {
        // âœ… CONFIGURED: 158 frames from updated feature1.mp4 (720px width, quality 25)
        // Ping-pong loop: plays forward then reverse
        framesDir: "https://liberty-shaders.vercel.app/feature_frames_1",
        totalFrames: 158,
        fps: 30,
        pingPong: true  // Enable forward-reverse looping
      },
      2: {
        // âœ… CONFIGURED: 103 frames from updated feature2.mp4 (720px width, quality 25)
        // Ping-pong loop: plays forward then reverse
        framesDir: "https://liberty-shaders.vercel.app/feature_frames_2",
        totalFrames: 103,
        fps: 30,
        pingPong: true  // Enable forward-reverse looping
      },
      3: {
        // âœ… CONFIGURED: 150 frames from updated feature3.mp4 (960px width, quality 50)
        // Ping-pong loop: plays forward then reverse
        framesDir: "https://liberty-shaders.vercel.app/feature_frames_3",
        totalFrames: 150,
        fps: 30,
        pingPong: true  // Enable forward-reverse looping
      }
    };

    const config = FEATURE_CONFIGS[featureNumber];
    const img = canvas.querySelector("img");
    
    if (!img || !img.src) {
      console.error(`âŒ Feature ${featureNumber}: Image not found in container!`);
      return;
    }

    console.log(`âœ… Feature ${featureNumber}: Container and image found`);
    console.log(`ğŸ“¸ Feature ${featureNumber}: Image source:`, img.src);

    // Get delay from custom attribute (in milliseconds)
    const delayMs = parseInt(canvas.getAttribute('shader-delay')) || 0;
    console.log(`â±ï¸ Feature ${featureNumber}: Delay: ${delayMs}ms`);

    img.style.opacity = "0";
    img.style.pointerEvents = "none";

    // Check if frame sequence is configured
    const hasFrameSequence = config.framesDir && config.totalFrames > 0;
    
    if (hasFrameSequence) {
      console.log(`ğŸï¸ Feature ${featureNumber}: Frame sequence enabled (${config.totalFrames} frames)`);
    } else {
      console.log(`ğŸ–¼ï¸ Feature ${featureNumber}: Static image mode (no frame sequence configured)`);
    }

    /* ---------- HELPER: PROCESS UNIFORMS ---------- */
    async function processUniforms(props) {
      const out = {};
      const promises = [];

      Object.entries(props).forEach(([k, v]) => {
        if (typeof v === "string") {
          const i = new Image();
          i.crossOrigin = "anonymous";
          const p = new Promise((res, rej) => {
            i.onload = () => { out[k] = i; res(); };
            i.onerror = rej;
          });
          i.src = v;
          promises.push(p);
        } else {
          out[k] = v;
        }
      });

      await Promise.all(promises);
      return out;
    }

    /* ---------- PRESET ---------- */
    const preset = {
      ...defaultObjectSizing,
      fit: "cover",
      speed: 0,
      frame: 0,
      colorBack: "#ffffff",
      colorFront: "#b2aeae",
      size: 0.6,
      radius: 2,
      contrast: 0.01,
      originalColors: true,
      inverted: false,
      grainMixer: 0,
      grainOverlay: 0,
      grainSize: 0.5,
      grid: "square",
      type: "holes",
      image: img.src
    };

    /* ---------- UNIFORMS ---------- */
    const uniformsProp = {
      u_image: preset.image,
      u_size: preset.size,
      u_radius: preset.radius,
      u_contrast: preset.contrast,
      u_originalColors: preset.originalColors,
      u_inverted: preset.inverted,
      u_grainMixer: preset.grainMixer,
      u_grainOverlay: preset.grainOverlay,
      u_grainSize: preset.grainSize,
      u_rotation: preset.rotation,
      u_scale: preset.scale,
      u_offsetX: preset.offsetX,
      u_offsetY: preset.offsetY,
      u_originX: preset.originX,
      u_originY: preset.originY,
      u_worldWidth: preset.worldWidth,
      u_worldHeight: preset.worldHeight,
      u_colorFront: getShaderColorFromString(preset.colorFront),
      u_colorBack: getShaderColorFromString(preset.colorBack),
      u_grid: HalftoneDotsGrids[preset.grid],
      u_type: HalftoneDotsTypes[preset.type],
      u_fit: ShaderFitOptions[preset.fit]
    };

    try {
      const uniforms = await processUniforms(uniformsProp);

      const shader = new ShaderMount(
        canvas,
        halftoneDotsFragmentShader,
        uniforms,
        {},
        preset.speed,
        preset.frame,
        preset.minPixelRatio,
        preset.maxPixelCount,
        preset.mipmaps
      );

      // Force initial state
      shader.setUniforms({ u_size: 1 });
      console.log(`âœ… Feature ${featureNumber}: Shader created successfully`);

      // If frame sequence is configured, frames load ON-DEMAND when trigger enters viewport
      let frameImages = [];
      let framesLoaded = 0;
      let animationReady = false;
      let loadingStarted = false;

      async function loadAllFrames() {
        if (loadingStarted) return;
        loadingStarted = true;
        
        const BATCH_SIZE = 20;
        
        async function loadBatch(start, end) {
          const promises = [];
          for (let i = start; i <= end && i <= config.totalFrames; i++) {
            const frameImg = new Image();
            frameImg.crossOrigin = "anonymous";
            const paddedIndex = String(i).padStart(4, "0");
            
            const promise = new Promise((resolve) => {
              frameImg.onload = () => { framesLoaded++; resolve(); };
              frameImg.onerror = () => resolve();
            });
            
            frameImg.src = `${config.framesDir}/frame_${paddedIndex}.webp`;
            frameImages[i - 1] = frameImg;
            promises.push(promise);
          }
          await Promise.all(promises);
        }

        console.log(`â³ Feature ${featureNumber}: Loading ${config.totalFrames} frames...`);
        
        // Load ALL frames
        for (let batch = 0; batch * BATCH_SIZE < config.totalFrames; batch++) {
          const start = batch * BATCH_SIZE + 1;
          const end = Math.min((batch + 1) * BATCH_SIZE, config.totalFrames);
          await loadBatch(start, end);
          console.log(`ğŸ“¦ Feature ${featureNumber}: ${framesLoaded}/${config.totalFrames} frames loaded...`);
        }
        
        console.log(`âœ… Feature ${featureNumber}: All ${config.totalFrames} frames loaded!`);
        animationReady = true;
      }

      if (!hasFrameSequence) {
        animationReady = true; // Static image mode - always ready
      }

      // Frame animation loop with ping-pong support (using requestAnimationFrame)
      function startFrameAnimation() {
        if (!hasFrameSequence) return;
        
        const loopType = config.pingPong ? "ping-pong" : "normal";
        console.log(`ğŸ¥ Feature ${featureNumber}: Starting frame animation (${loopType} loop)...`);
        
        let currentFrame = 0;
        let direction = 1; // 1 for forward, -1 for reverse
        const frameDuration = 1000 / config.fps;
        let lastFrameTime = 0;
        let isPaused = false;

        // âš¡ PERFORMANCE: Pause animation when not visible
        const visibilityObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              isPaused = !entry.isIntersecting;
              if (!isPaused) lastFrameTime = 0; // Reset timing
            });
          },
          { threshold: 0.1 }
        );
        visibilityObserver.observe(canvas);

        function animationLoop(timestamp) {
          requestAnimationFrame(animationLoop);
          
          // âš¡ PERFORMANCE: Skip when paused/not visible
          if (isPaused) return;
          if (!animationReady || framesLoaded < 20) return;
          
          // Initialize lastFrameTime on first run
          if (lastFrameTime === 0) {
            lastFrameTime = timestamp;
          }
          
          const elapsed = timestamp - lastFrameTime;
          
          if (elapsed >= frameDuration) {
            const maxFrame = Math.min(framesLoaded, config.totalFrames) - 1;
            const nextImage = frameImages[currentFrame];
            
            if (nextImage && nextImage.complete) {
              shader.setUniforms({ u_image: nextImage });
            }
            
            if (config.pingPong) {
              // Ping-pong loop: forward then reverse
              currentFrame += direction;
              
              // Reverse direction at boundaries (use loaded frames only)
              if (currentFrame >= maxFrame) {
                currentFrame = maxFrame;
                direction = -1;
              } else if (currentFrame <= 0) {
                currentFrame = 0;
                direction = 1;
              }
            } else {
              // Normal loop: restart from beginning
              currentFrame = (currentFrame + 1) % (maxFrame + 1);
            }
            
            // Account for any lag
            lastFrameTime = timestamp - (elapsed % frameDuration);
          }
        }

        requestAnimationFrame(animationLoop);
      }

      // Return controller for external trigger (Two-Part Animation)
      const controller = {
        pixelAnimationStarted: false,
        sequenceStarted: false,
        
        // Called when trigger enters viewport - starts loading + pixel animation
        startPixelAnimation() {
          if (this.pixelAnimationStarted) return;
          this.pixelAnimationStarted = true;
          
          // Start loading frames NOW (on-demand when trigger visible)
          if (hasFrameSequence) {
            loadAllFrames();
          }
          
          console.log(`ğŸ¬ Feature ${featureNumber} Part 1: Starting pixel animation (on first frame)...`);
          
          // Ensure first frame is displayed during pixel animation (if already loaded)
          if (hasFrameSequence && frameImages[0] && frameImages[0].complete) {
            shader.setUniforms({ u_image: frameImages[0] });
          }
          
          setTimeout(() => {
            animate(1, 0.1, {
              duration: 6,
              ease: [0.36, -0.01, 0.41, 1.01],
              onUpdate: (u_size) => {
                shader.setUniforms({ u_size });
              },
              onComplete: () => {
                console.log(`âœ… Feature ${featureNumber} Part 1 complete! Starting Part 2...`);
                // Part 2: Start image sequencing after pixel animation
                this.startSequence();
              }
            });
          }, delayMs);
        },
        
        // Part 2: Image sequencing (after pixel animation completes)
        startSequence() {
          if (this.sequenceStarted) return;
          this.sequenceStarted = true;
          
          if (hasFrameSequence) {
            startFrameAnimation();
          }
        }
      };

      return controller;

    } catch (error) {
      console.error(`âŒ Feature ${featureNumber}: Initialization error:`, error);
      return null;
    }
  }

  // Wait for DOM and Webflow to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initShaders);
  } else {
    // DOM is already ready
    initShaders();
  }

  // Also try Webflow's page ready event as backup
  if (window.Webflow) {
    window.Webflow.push(initShaders);
  }
</script>

================================================================================
DONE! This version includes:
- âœ… DOM ready checks
- âœ… Detailed console logging for debugging
- âœ… Error handling
- âœ… Proper initialization order
- âœ… LOGO LOADER: logo-loader="1" hides after MAX(3 seconds, hero frames loaded)
- âœ… TWO-PART ANIMATION: Part 1 = pixel animation on first frame, Part 2 = image sequencing
- âœ… HERO VIDEO: shader="video" with 227-frame sequence animation
- âœ… FEATURE SHADERS: feature="1", feature="2", feature="3" 
- âœ… EXTERNAL TRIGGERS: feature-trigger="1", "2", "3" on left-side text content
- âœ… Triggers at 40% from top of viewport (perfect for sticky panel layouts)
- âœ… Each feature supports image sequence animation with configurable frame directory
- âœ… Easy configuration: Set framesDir, totalFrames, and fps for each feature in FEATURE_CONFIGS
- âœ… Support for shader-delay attribute (delay in milliseconds)
- âœ… Features work in both static image mode and frame sequence mode
- âœ… ON-DEMAND LOADING: Feature frames load only when their trigger enters viewport
- âš ï¸ REMOVED: shader="pixel" attribute is no longer used

LOGO LOADER SETUP:
Add a wrapper div with custom attribute:
  - logo-loader="1"
The loader will:
  1. Show for minimum 3 seconds (even if frames load faster)
  2. Wait for all hero frames to finish loading
  3. Fade out with 0.5s opacity transition
  4. Then trigger hero pixel animation

ANIMATION FLOW:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Page Load                                                                  â”‚
â”‚    â”œâ”€ Logo loader shows                                                     â”‚
â”‚    â”œâ”€ 3 second timer starts                                                 â”‚
â”‚    â”œâ”€ Hero frames start loading                                             â”‚
â”‚    â”œâ”€ Wait for MAX(3 seconds, hero frames loaded)                           â”‚
â”‚    â”œâ”€ Logo loader fades out                                                 â”‚
â”‚    â”œâ”€ Hero Part 1: Pixel animation (6s) on FIRST frame                      â”‚
â”‚    â””â”€ Hero Part 2: Image sequencing starts after Part 1 completes           â”‚
â”‚                                                                             â”‚
â”‚  Feature Trigger (scroll - when trigger enters viewport)                    â”‚
â”‚    â”œâ”€ Feature frames START LOADING NOW (on-demand)                          â”‚
â”‚    â”œâ”€ Feature Part 1: Pixel animation (6s) on FIRST frame                   â”‚
â”‚    â””â”€ Feature Part 2: Image sequencing starts after Part 1 completes        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SETUP FOR STICKY PANEL LAYOUT:
Right side (sticky panel):
  - feature="1", feature="2", feature="3" on image containers

Left side (scrolling text content):
  - feature-trigger="1" on the text section for feature 1
  - feature-trigger="2" on the text section for feature 2  
  - feature-trigger="3" on the text section for feature 3

HOW TO ADD FRAME SEQUENCES TO FEATURES:
1. Upload your frame images for each feature to Webflow Assets
2. In the code below, find FEATURE_CONFIGS and update:
   - framesDir: "https://your-webflow-url.com/feature-frames" (your asset URL)
   - totalFrames: 150 (number of frames)
   - fps: 30 (frames per second)
3. Leave as null/0 to use static image mode (no animation)

ALL FRAMES STATUS:

Hero Video:
âœ… Frames extracted: 227 frames from flora5.mp4 (7.56 seconds @ 30fps)
âœ… Frame specs: 960px width Ã— 540px height (16:9), WebP format, quality 50
âœ… Source: 1280Ã—720 scaled to 960Ã—540 for performance
âœ… Total size: 3.5MB (~13KB per frame)
âœ… Configured URL: https://liberty-shaders.vercel.app/frames

FEATURE FRAMES STATUS:

Feature 1:
âœ… Frames extracted: 158 frames from updated feature1.mp4 (5.26s @ 30fps)
âœ… Frame specs: 720px width Ã— 892px height, WebP format, quality 25
âœ… Total size: 3.1MB
âœ… Animation: Ping-pong loop (forward â†’ reverse â†’ repeat)
âœ… Configured URL: https://liberty-shaders.vercel.app/feature_frames_1

Feature 2:
âœ… Frames extracted: 103 frames from updated feature2.mp4 (3.43s @ 30fps)
âœ… Frame specs: 720px width Ã— 916px height, WebP format, quality 25
âœ… Total size: 824KB
âœ… Animation: Ping-pong loop (forward â†’ reverse â†’ repeat)
âœ… Configured URL: https://liberty-shaders.vercel.app/feature_frames_2

Feature 3:
âœ… Frames extracted: 150 frames from updated feature3.mp4 (5s @ 30fps)
âœ… Frame specs: 960px width Ã— 1199px height, WebP format, quality 50
âœ… Total size: 11MB
âœ… Animation: Ping-pong loop (forward â†’ reverse â†’ repeat)
âœ… Configured URL: https://liberty-shaders.vercel.app/feature_frames_3

ğŸ‰ ALL FEATURES UPDATED! 

LATEST UPDATES:
- âœ… Logo loader integration (logo-loader="1") - hides after MAX(3 seconds, hero frames loaded)
- âœ… Two-part animation: Part 1 = pixel animation on first frame, Part 2 = image sequencing
- âœ… ON-DEMAND feature loading: Feature frames only load when trigger enters viewport
- âœ… Ping-pong loop implemented in code (no duplicate frames)
================================================================================


